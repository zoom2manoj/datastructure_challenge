Data Structure & Algorithm, Problem solving in Java

1. Find maximum level sum in Binary Tree

2. Split a Circular Linked List into two halves

3. Rotate a Linked List

4. Add two linked list in reverse order

5. Add two Linkedlist

6. Occurence count

7. Root to leaf paths having equal lengths in a Binary Tree

Array Rotations: 
1. Array Rotation(A Juggling Algorithm).
2. Reverse Array Rotation.
3. Cyclic Array Rotation.
4. Search an element in a sorted and rotated array.
5. Given a sorted and rotated array, find if there is a pair with a given sum.
6. Lower Element from sorted and rotated Array.
7. Find maximum value of Sum( i*arr[i]) with only rotations on given array allowed.
8. Maximum sum of i*arr[i] among all rotations of a given array.
9. Find the Rotation Count in Rotated Sorted array
10.Quickly find multiple left rotations of an array.
11.Find a sorted subsequence of size 3 in linear time
12.Find a sorted subsequence of size 4 in an array in linear time
13.Dynamic Programming | Set 18 (Partition problem)




Arrangement Rearrangement :
1. Rearrange positive and negative numbers in O(n) time and O(1) extra space.
2. Reverse Array.
3. Sort an array in wave form
4. Rearrange positive and negative numbers with constant extra space
5. Three way partitioning of an array around a given range
6. Rearrange an array in maximum minimum form (O(1) extra space)
7. Maximum Length Bitonic Subarray | Set 1 (O(n) tine and O(n) space)
8. Segregate 0s and 1s in an array
9. Segregate Even and Odd numbers
10.Longest Bitonic Subsequence
11.Largest subarray with equal number of 0s and 1s

Graph : 
1. DFS (Iterative & Recursive)
2. BFS

++ Normal Sort Algorithm
1. Delta Encoding
2. Polygon check
3. Sum Array
4. Anagram


Sorting Algorithms : 

1. Bubble Sorting
2. Selection Sorting
3. Insertion Sorting
4. Quick Sorting
5. Merge Sorting
6. Heap Sorting

Design Patterns:

Creational Design Pattern:
 1. Singleton Pattern 
 2. Factory Pattern
 3. Builder Pattern
 4. Prototype Pattern
 
 Important Points:
 
 1.Factory Pattern:
 
   A. We can keep factory class Singleton or we can keep the method that returns the sublcass as static  
   B. Approach to code for interface rather than implementation  
   C. Removes the instatiation of actual implemention classes from client code  
   D. Code will more rebust, less coupled and easy to extend.   
   E. Provide abstraction between implemention and client classes through interitance  
   
 2. Abstract Factory Pattern:    
   A. All pattern is same as factory pattern, few addon feature is added.   
   B. Factory of Factories, it's can be easily extended to accommodate more.   
   C. Avoice conditional logic of factory pattern.   
 
Structural Design Pattern:
 1. Adapter Design Pattern
 2. Composition Design Pattern
 3. Proxy Design Pattern
 4. Flyweight Design Pattern
 5. Bridge Design Pattern
 6. Facade Design Pattern
 7. Decorator Design Pattern
 
Behavioral Design Pattern:
 1. Mediator Design Pattern
 2. Chain of responsibility Design Pattern
 3. Observer Design Pattern
 4. Command Design Pattern
 5. State Design Pattern
 6. Visitor Design Pattern
 
 
 
 
Currently, process is going on, will update soon.
